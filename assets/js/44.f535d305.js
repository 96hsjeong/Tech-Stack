(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{385:function(_,v,t){"use strict";t.r(v);var r=t(19),e=Object(r.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"그래프-graph"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#그래프-graph"}},[_._v("#")]),_._v(" 그래프(Graph)")]),_._v(" "),t("p",[t("em",[_._v("written by sohyeon, hyemin 💡")])]),_._v(" "),t("br"),_._v(" "),t("h2",{attrs:{id:"_1-그래프란"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-그래프란"}},[_._v("#")]),_._v(" 1. 그래프란?")]),_._v(" "),t("p",[t("code",[_._v("그래프(Graph)")]),_._v("는 노드(node)와 간선(가지, edge)을 하나로 모아 놓은 자료구조를 말한다.")]),_._v(" "),t("p",[t("code",[_._v("즉, 연결되어 있는 객체 간의 관계를 표현할 수 있는 자료구조")])]),_._v(" "),t("br"),_._v(" "),t("h2",{attrs:{id:"_2-그래프의-특징"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-그래프의-특징"}},[_._v("#")]),_._v(" 2. 그래프의 특징")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("그래프는 "),t("code",[_._v("네트워크 모델")]),_._v("이다.")])]),_._v(" "),t("li",[t("p",[_._v("2개 이상의 경로가 가능하다.")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("self-loop")]),_._v(" 뿐만 아니라 "),t("code",[_._v("loop/circuit")]),_._v("전부 가능하다.")])]),_._v(" "),t("li",[t("p",[_._v("트리와 달리 "),t("code",[_._v("루트, 부모-자식의 개념이 없다.")])])]),_._v(" "),t("li",[t("p",[_._v("순회는 "),t("code",[_._v("DFS(Depth-First Search)")]),_._v("나 "),t("code",[_._v("BFS(Breadth-First Search)")]),_._v("로 이루어진다.")])]),_._v(" "),t("li",[t("p",[_._v("그래프는 "),t("code",[_._v("순환(Cyclic)")]),_._v(" 혹은 "),t("code",[_._v("비순환(Acyclic)")]),_._v("이다.")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("순환 그래프(Cycle)")]),t("br"),_._v("\n단순 경로의 시작 정점과 종료 정점이 동일한 경우를 말한다.")]),_._v(" "),t("li",[t("strong",[_._v("비순환 그래프")]),t("br"),_._v("\n사이클이 없는 그래프를 의미한다.")])])]),_._v(" "),t("li",[t("p",[_._v("그래프는 "),t("code",[_._v("방향 그래프(Undirected Graph)")]),_._v("와 "),t("code",[_._v("무방향 그래프(Directed Graph)")]),_._v("가 있다.")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("무방향 그래프")]),t("br"),_._v("\n간선을 통해서 양방향으로 갈 수 있다.")]),_._v(" "),t("li",[t("strong",[_._v("방향 그래프")]),t("br"),_._v("\n간선에 방향성이 존재하는 그래프이다.")])])]),_._v(" "),t("li",[t("p",[_._v("그래프는 "),t("code",[_._v("연결 그래프(Connected Graph)")]),_._v(" 혹은 "),t("code",[_._v("비연결 그래프(Disconnected Graph)")]),_._v("이다.")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("연결 그래프")]),t("br"),_._v("\n무방향 그래프에서 모든 정점쌍에 대해 항상 경로가 존재하는 그래프  "),t("code",[_._v("ex) 트리")])]),_._v(" "),t("li",[t("strong",[_._v("비연결 그래프")]),t("br"),_._v("\n무방향 그래프에서 특정 정점쌍 사이에 경로가 존재하지 않는 그래프")])])]),_._v(" "),t("li",[t("p",[_._v("이외에도 그래프의 종류에는 "),t("code",[_._v("가중치 그래프(Weighted Graph)")]),_._v(", "),t("code",[_._v("완전 그래프(Complete Graph)")]),_._v(" 등이 있다.")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("가중치 그래프")]),t("br"),_._v("\n간선에 비용이나 가중치가 할당된 그래프")]),_._v(" "),t("li",[t("strong",[_._v("완전 그래프")]),t("br"),_._v("\n그래프에 속해 있는 모든 정점이 서로 연결되어 있는 그래프")])])])]),_._v(" "),t("br"),_._v(" "),t("h2",{attrs:{id:"_3-그래프의-관련-용어"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-그래프의-관련-용어"}},[_._v("#")]),_._v(" 3. 그래프의 관련 용어")]),_._v(" "),t("ul",[t("li",[t("p",[t("strong",[_._v("정점(vertex)")]),t("br"),_._v("\n위치를 의미한다. (node와 같은 의미)")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("간선(edge)")]),t("br"),_._v("\n위치 간의 관계로 노드(node)를 연결하는 선이다.")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("인접 정점(adjacent vertex)")]),t("br"),_._v("\n간선에 의해 직접 연결된 정점을 의미한다.")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("정점의 차수(degree)")]),t("br"),_._v("\n무방향 그래프에서 하나의 정점에 인접한 정점의 수를 의미한다."),t("br"),_._v(" "),t("code",[_._v("무방향 그래프에 존재하는 정점의 모든 차수의 합 = 그래프의 간선 수의 2배")])])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("진입 차수(in-degree)")]),t("br"),_._v("\n방향 그래프에서 외부에서 오는 간선의 수를 의미한다.")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("진출 차수(out-degree)")]),t("br"),_._v("\n방향 그래프에서 외부로 가는 간선의 수를 의미한다.")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("경로 길이(path length)")]),t("br"),_._v("\n경로를 구성하는 데 사용된 간선의 수를 의미한다.")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("단순 경로(simple path)")]),t("br"),_._v("\n경로 중에서 반복되는 정점이 없는 경우를 말한다.")])]),_._v(" "),t("li",[t("p",[t("strong",[_._v("사이클(cycle)")]),t("br"),_._v("\n단순 경로의 시작 정점과 종료 정점이 같은 경우를 말한다.")])])]),_._v(" "),t("br"),_._v(" "),t("h2",{attrs:{id:"_4-그래프와-트리의-차이점"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-그래프와-트리의-차이점"}},[_._v("#")]),_._v(" 4. 그래프와 트리의 차이점")]),_._v(" "),t("table",[t("thead",[t("tr",[t("th"),_._v(" "),t("th",[_._v("그래프(Graph)")]),_._v(" "),t("th",[_._v("트리(Tree)")])])]),_._v(" "),t("tbody",[t("tr",[t("td",[_._v("정의")]),_._v(" "),t("td",[_._v("노드(node)와 그 노드를 연결하는 간선(edge)을 하나로 모아 놓은 자료구조")]),_._v(" "),t("td",[_._v("그래프의 한 종류"),t("br"),_._v("DAG(Directed Acyclic Graph)의 한 종류")])]),_._v(" "),t("tr",[t("td",[_._v("방향성")]),_._v(" "),t("td",[_._v("방향그래프(Directed), 무방향 그래프(Undirected) 모두 존재")]),_._v(" "),t("td",[_._v("방향그래프(Directed)")])]),_._v(" "),t("tr",[t("td",[_._v("사이클")]),_._v(" "),t("td",[_._v("사이클(Cycle)와 자체 간선(self-loop) 가능"),t("br"),_._v("순환 그래프(Cyclic), 비순환 그래프(Acyclic) 모두 존재")]),_._v(" "),t("td",[_._v("사이클(Cycle)와 자체 간선(self-loop) 불가능"),t("br"),_._v("비순환 그래프(Acyclic)")])]),_._v(" "),t("tr",[t("td",[_._v("루트")]),_._v(" "),t("td",[_._v("루트 노드의 개념이 없음")]),_._v(" "),t("td",[_._v("한 개의 루트 노드만이 존재, 모든 자식 노드는 한 개의 부모 노드만을 가짐")])]),_._v(" "),t("tr",[t("td",[_._v("부모-자식")]),_._v(" "),t("td",[_._v("부모-자식의 개념이 없음")]),_._v(" "),t("td",[_._v("부모-자식 관계, top-bottom 또는 bottom-top으로 이루어짐")])]),_._v(" "),t("tr",[t("td",[_._v("모델")]),_._v(" "),t("td",[_._v("네트워크 모델")]),_._v(" "),t("td",[_._v("계층 모델")])]),_._v(" "),t("tr",[t("td",[_._v("순회")]),_._v(" "),t("td",[_._v("DFS, BFS")]),_._v(" "),t("td",[_._v("DFS, BFS안의 Pre-order, In-order, Post-order")])]),_._v(" "),t("tr",[t("td",[_._v("간선의 수")]),_._v(" "),t("td",[_._v("그래프에 따라 간선의 수가 다름"),t("br"),_._v("간선이 없을 수도 있음")]),_._v(" "),t("td",[_._v("노드가 N인 트리는 항상 N-1의 간선을 가짐")])]),_._v(" "),t("tr",[t("td",[_._v("경로")]),_._v(" "),t("td",[_._v("-")]),_._v(" "),t("td",[_._v("임의의 두 노드 간의 경로는 유일")])]),_._v(" "),t("tr",[t("td",[_._v("예시 및 종류")]),_._v(" "),t("td",[_._v("지도, 지하철 노선도의 최단 경로, 전기 회로의 소자들, 도로(교차점과 일방 통행길)")]),_._v(" "),t("td",[_._v("이진 트리, 이진 탐색 트리, 균형 트리(AVL트리, red-black 트리), 이진 힙(최대힙, 최소힙) 등")])])])]),_._v(" "),t("br"),_._v(" "),t("h2",{attrs:{id:"_5-그래프의-구현-2가지"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-그래프의-구현-2가지"}},[_._v("#")]),_._v(" 5. 그래프의 구현 2가지")]),_._v(" "),t("h3",{attrs:{id:"인접-리스트-adjacency-list"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#인접-리스트-adjacency-list"}},[_._v("#")]),_._v(" 인접 리스트(adjacency list)")]),_._v(" "),t("p",[_._v("인접 리스트로 그래프를 표현하는 것이 가장 일반적인 방법이다.")]),_._v(" "),t("ul",[t("li",[_._v("모든 정점(혹은 노드)을 인접 리스트에 저장한다.  즉, 각각의 정점에 인접한 정점들을 리스트로 표현한 것이다.\n"),t("ul",[t("li",[_._v("배열(혹은 해시테이블)과 배열의 각 인덱스마다 존재하는 또 다른 리스트(배열, 동적 가변 크기 배열(arraylist), 연결리스트(linked list) 등)를 이용해서 인접 리스트를 표현할 수 있다.")])])])]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("0 : 1\n1 : 2\n2 : 0, 3\n3 : 2\n4 : 6\n5 : 4\n6 : 5\n")])])]),t("ul",[t("li",[t("p",[_._v("무방향 그래프(undirected graph)에서 (a, b) 간선은 두 번 저장된다.")]),_._v(" "),t("ul",[t("li",[_._v("한 번은 a 정점에 인접한 간선을 저장하고 다른 한 번은 b에 인접한 간선을 저장한다.")])])]),_._v(" "),t("li",[t("p",[_._v("그래프에선 특정 노드에서 다른 모든 노드로 접근이 가능하지 않다 => Graph 클래스 필요")]),_._v(" "),t("ul",[t("li",[_._v("트리에선 특정 노드 하나(루트 노드)에서 다른 모든 노드로 접근이 가능 => Tree 클래스 불필요")])])])]),_._v(" "),t("h4",{attrs:{id:"ex-노드를-정의하는-간단한-클래스"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ex-노드를-정의하는-간단한-클래스"}},[_._v("#")]),_._v(" ex) 노드를 정의하는 간단한 클래스")]),_._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[_._v("class Graph {\n    public Node[] nodes;\n}\n\nclass Node {\n\n}\n")])])]),t("h3",{attrs:{id:"인접-행렬"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#인접-행렬"}},[_._v("#")]),_._v(" 인접 행렬")]),_._v(" "),t("p",[t("code",[_._v("인접 행렬")]),_._v("은 N X N 불린 행렬(boolean matrix)로서 matrix[i][j]가 true라면 i에서 j로의 간선이 있다는 뜻이다.")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("0과 1을 이용한 정수 행렬(integer matrix)을 사용할 수 있다.")])]),_._v(" "),t("li",[t("p",[t("code",[_._v("인접 리스트")]),_._v("에서는 어떤 노드에 인접한 노드들을 쉽게 찾을 수 있지만, "),t("code",[_._v("인접 행렬")]),_._v("에서는 어떤 노드에 인접한 노드를 찾기 위해서는 모든 노드를 전부 순회해야 알 수 있다.")])])]),_._v(" "),t("br"),_._v(" "),t("h2",{attrs:{id:"reference-additional-resources"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#reference-additional-resources"}},[_._v("#")]),_._v(" Reference & Additional Resources")]),_._v(" "),t("ul",[t("li",[t("p",[_._v("코딩 인터뷰 완전분석")])]),_._v(" "),t("li",[t("p",[t("a",{attrs:{href:"https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("https://gmlwjd9405.github.io/2018/08/13/data-structure-graph.html"),t("OutboundLink")],1)])])])])}),[],!1,null,null,null);v.default=e.exports}}]);