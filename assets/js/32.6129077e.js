(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{337:function(e,r,t){e.exports=t.p+"assets/img/tree.f96baa5f.jpg"},390:function(e,r,t){"use strict";t.r(r);var _=t(19),v=Object(_.a)({},(function(){var e=this,r=e.$createElement,_=e._self._c||r;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"트리-tree"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#트리-tree"}},[e._v("#")]),e._v(" 트리(Tree)")]),e._v(" "),_("p",[_("em",[e._v("written by sohyeon, hyemin 💡")])]),e._v(" "),_("br"),e._v(" "),_("h2",{attrs:{id:"_1-트리란"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-트리란"}},[e._v("#")]),e._v(" 1. 트리란?")]),e._v(" "),_("p",[_("code",[e._v("트리(tree)")]),e._v("는 그래프의 한 종류로, 데이터 사이의 계층 관계를 나타내는 자료구조를 말한다.")]),e._v(" "),_("br"),e._v(" "),_("h2",{attrs:{id:"_2-트리의-특징"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-트리의-특징"}},[e._v("#")]),e._v(" 2. 트리의 특징")]),e._v(" "),_("ul",[_("li",[_("p",[e._v("그래프의 한 종류로, "),_("code",[e._v("최소 연결 트리")]),e._v("라고 한다.")])]),e._v(" "),_("li",[_("p",[e._v("트리는 "),_("code",[e._v("계층 모델")]),e._v("이다.")])]),e._v(" "),_("li",[_("p",[e._v("트리는 "),_("code",[e._v("DAG(Directed Acyclic Graphs, 방향성이 있는 비순환 그래프)")]),e._v("의 한 종류로, "),_("code",[e._v("사이클이 없다.")])])]),e._v(" "),_("li",[_("p",[e._v("노드가 N개인 트리는 항상 "),_("code",[e._v("N-1개의 간선(가지, edge)")]),e._v("을 가진다.")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("한 개의 루트 노드")]),e._v("만이 존재하며, 모든 자식 노드는 한 개의 부모 노드만을 가진다.")])]),e._v(" "),_("li",[_("p",[_("code",[e._v("부모 - 자식 관계")]),e._v("이므로 흐름은 top-bottom 이나 bottom-top으로 이루어진다.")])]),e._v(" "),_("li",[_("p",[e._v("순회는 "),_("code",[e._v("Pre-order(전위), In-order(중위) 아니면 Post-order(후위)")]),e._v("로 이루어진다.")])]),e._v(" "),_("li",[_("p",[e._v("트리의 종류에는 "),_("code",[e._v("이진 트리, 이진 탐색 트리, 균형 트리(AVL 트리, red-black 트리), 이진 힙(최대힙, 최소힙)")]),e._v(" 등이 있다.")])])]),e._v(" "),_("br"),e._v(" "),_("h2",{attrs:{id:"_3-트리-관련-용어"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-트리-관련-용어"}},[e._v("#")]),e._v(" 3. 트리 관련 용어")]),e._v(" "),_("p",[e._v("트리를 구성하는 요소는 "),_("code",[e._v("노드(node)")]),e._v(" 와 "),_("code",[e._v("간선(가지, edge)")]),e._v("이다.")]),e._v(" "),_("img",{attrs:{src:t(337),width:"600px"}}),e._v(" "),_("ul",[_("li",[_("p",[_("strong",[e._v("루트 노드(root node)")]),_("br"),e._v("\n트리의 가장 윗부분에 위치하는 노드로, 0개 이상의 자식 노드를 가지고 있다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("단말 노드(leaf node)")]),_("br"),e._v("\n트리의 가장 아랫부분에 위치하는 노드로, 더 이상 뻗어나갈 수 없는 마지막에 위치한 노드를 말한다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("내부(internal) 노드")]),_("br"),e._v("\n루트를 포함하여 리프를 제외한 노드로, 다른 용어로 끝이 아닌 노드(non-terminal node)라고 한다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("자식 노드(child node)")]),_("br"),e._v("\n어떤 노드로부터 간선으로 연결된 아래쪽 노드로, 노드는 자식을 여러 개 가질 수 있다. 예를 들어 X는 1개, Y는 2개의 자식을 가지고 있다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("부모 노드(Parent Node)")]),_("br"),e._v("\n어떤 노드에서 간선으로 연결된 위쪽 노드로, 노드는 1개의 부모를 가진다. 예를 들어 Y의 부모는 X이다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("형제 노드(Sibling Node)")]),_("br"),e._v("\n같은 부모를 가지는 노드를 말한다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("조상")]),_("br"),e._v("\n어떤 노드에서 간선으로 연결된 위쪽 노드 모두를 말한다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("자손")]),_("br"),e._v("\n어떤 노드에서 간선으로 연결된 아래쪽 노드 모두를 말한다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("노드의 레벨(level)")]),_("br"),e._v("\n루트로부터 얼마나 떨어져 있는지에 대한 값을 말한다. 루트의 레벨은 0이고 루트로부터 간선이 하나씩 아래로 뻗어나갈 때마다 레벨이 1씩 늘어난다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("노드의 크기(size)")]),_("br"),e._v("\n자신을 포함한 모든 자손 노드의 개수를 말한다. 예를 들어 X의 크기는 4이다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("노드의 깊이(depth)")]),_("br"),e._v("\n루트에서 어떤 노드에 도달하기 위해 거쳐야 하는 간선의 수를 말한다. 예를 들어 Y의 깊이는 2이다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("트리의 차수(degree of tree)")]),_("br"),e._v("\n노드가 갖는 자식의 수를 말한다. 또한, 모든 노드의 차수가 n 이하인 트리를 n진 트리라고 한다. 예를 들어 그림은 모든 노드의 자식이 3개 이하이므로 3진 트리이다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("트리의 높이(height)")]),_("br"),e._v("\n루트로부터 가장 멀리 떨어진 리프까지의 거리를 말한다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("서브 트리")]),_("br"),e._v("\n트리 안에서 다시 어떤 노드를 루트로 정하고 그 자손으로 이루어진 트리를 말한다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("널 트리")]),_("br"),e._v("\n노드, 간선이 없는 트리를 말한다.")])]),e._v(" "),_("li",[_("p",[_("strong",[e._v("순서 트리와 무순서 트리")]),_("br"),e._v("\n형제 노드의 순서를 따지면 순서 트리(ordered tree), 따지지 않으면 무순서 트리(unordered tree)라고 한다.")])])]),e._v(" "),_("br"),e._v(" "),_("h2",{attrs:{id:"reference-additional-resources"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#reference-additional-resources"}},[e._v("#")]),e._v(" Reference & Additional Resources")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://gmlwjd9405.github.io/2018/08/12/data-structure-tree.html/"),_("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=v.exports}}]);