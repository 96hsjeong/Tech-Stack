(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{285:function(t,a,r){"use strict";r.r(a);var e=r(19),_=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"avl트리-avl-tree"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#avl트리-avl-tree"}},[t._v("#")]),t._v(" AVL트리 (AVL Tree)")]),t._v(" "),r("p",[r("em",[t._v("written by sohyeon, hyemin 💡")])]),t._v(" "),r("br"),t._v(" "),r("h2",{attrs:{id:"_1-avl트리란"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-avl트리란"}},[t._v("#")]),t._v(" 1. AVL트리란?")]),t._v(" "),r("p",[r("code",[t._v("AVL트리")]),t._v("는 쉽게 말해 "),r("code",[t._v("균형잡인 이진탐색트리")]),t._v("이다."),r("br"),t._v("\n서브트리의 높이를 적절하게 제어해 전체 트리가 어느 한쪽으로 늘어지지 않도록 한 이진탐색트리의 일종이다."),r("br"),t._v("\n트리의 높이가 h일 때 이진탐색트리의 계산복잡성은 O(h)이기 때문에"),r("br"),t._v("\n균형된 트리를 만들어 h를 줄이고자 하는 발상에서 비롯됐습니다.")]),t._v(" "),r("img",{attrs:{src:"/images/DataStructure/resources/avltree.PNG",width:"90%"}}),t._v(" "),r("p",[t._v("루트 노드의 좌측 서브노드와 우측 서브노드의 높이 차이가 1보다 크지 않은 형태이다.")]),t._v(" "),r("h3",{attrs:{id:"_1-1-균형계수-bf-balance-factor"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-균형계수-bf-balance-factor"}},[t._v("#")]),t._v(" 1-1. 균형계수(BF, Balance Factor)")]),t._v(" "),r("img",{attrs:{src:"/images/DataStructure/resources/avl_add.PNG",width:"600px"}}),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",[r("code",[t._v("BalanceFactor = height(left subtree) - height(right subtree)\n")])])]),r("p",[t._v("왼쪽 서브트리의 높이에서 오른쪽 서브트리의 높이를 뺀 것이다."),r("br"),t._v("\n두 서브트리의 높이가 같거나 잎새노드라면 BF는 0이다(empty tree의 BF는 -1로 정의)."),r("br"),t._v("\nBF는 정수 범위 [-1, + 1]인데 노드 삽입 이후에 그래프의 균형 계수가 -1보다 작거나 +1보다 클 수 있다."),r("br"),t._v("\n이 경우 회전을 통해 균형을 맞춰줄 수 있다.")]),t._v(" "),r("h2",{attrs:{id:"_2-회전-rotation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-회전-rotation"}},[t._v("#")]),t._v(" 2. 회전 (Rotation)")]),t._v(" "),r("p",[t._v("삽입으로 인행 불균형해진 그래프의 균형을 맞춘다.")]),t._v(" "),r("h3",{attrs:{id:"_2-1-single-rotation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-single-rotation"}},[t._v("#")]),t._v(" 2-1. Single Rotation")]),t._v(" "),r("p",[t._v("single rotation은 rotation을 한 차례 수행해 BF가 0인 균형잡힌 그래프를 얻을 수 있는 경우를 가리킨다."),r("br"),t._v("\nSingle Rotation은 회전 방향에 따라 두가지로 나뉘어진다.")]),t._v(" "),r("img",{staticStyle:{margin:"10px"},attrs:{src:"/images/DataStructure/resources/avl_sr2.png",width:"600px"}}),t._v(" "),r("ul",[r("li",[t._v("Single Left Rotation")]),t._v(" "),r("li",[t._v("Single Right Rotation")])]),t._v(" "),r("h4",{attrs:{id:"실행-기준"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#실행-기준"}},[t._v("#")]),t._v(" 실행 기준")]),t._v(" "),r("p",[t._v("삽입 연산의 single rotation은 다음 두 가지 경우에 실시된다.")]),t._v(" "),r("img",{attrs:{src:"/images/DataStructure/resources/before_srr.PNG",width:"400px"}}),t._v(" "),r("p",[r("code",[t._v("X")]),t._v(": BF의 절대값이 2 이상이면서 새 노드와 가장 가까운 조상 노드"),r("br"),t._v(" "),r("code",[t._v("Y")]),t._v(": 자식노드, BF 절대값이 1 이하인 노드")]),t._v(" "),r("ul",[r("li",[t._v("Y가 X의 왼쪽 자식노드, Y의 왼쪽 서브트리에 새 노드가 삽입된 상태\n: Y를 기준으로 right rotation")]),t._v(" "),r("li",[t._v("Y가 X의 오른쪽 자식노드, Y의 오른쪽 서브트리에 새 노드가 삽입된 상태\n: Y를 기준으로 left rotation")])]),t._v(" "),r("h4",{attrs:{id:"single-right-rotation-예시"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#single-right-rotation-예시"}},[t._v("#")]),t._v(" Single Right Rotation 예시")]),t._v(" "),r("img",{attrs:{src:"/images/DataStructure/resources/avl_srr.PNG",width:"600px"}}),t._v(" "),r("p",[t._v("위의 예시를 보면 'BF가 2 이상, 2 이하일 때 rotation을 실시한다'는 조건에 부합한다."),r("br"),t._v("\nX의 왼쪽 자식노드인 Y를 기준으로 single rotation을 실시한다."),r("br"),t._v("\nY를 새로운 루트노드로 만들고 T1만 h+1이고 나머지는 모두 h인 점을 감안하면"),r("br"),t._v("\nrotation 실시 후의 X, Y의 BF는 각각 0, 0이 되어 균형 트리를 이룬다.")]),t._v(" "),r("h3",{attrs:{id:"_2-2-double-rotation"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-double-rotation"}},[t._v("#")]),t._v(" 2-2. Double Rotation")]),t._v(" "),r("p",[t._v("rotation 한 차례만으로 원하는 삽입 결과를 내지 못하는 케이스가 존재한다."),r("br"),t._v("\n이 경우 두번의 rotation을 수행해 균형을 맞춘다.")]),t._v(" "),r("p",[t._v("single rotation과 마찬가지로 방향에 따라 두가지로 나뉜다.")]),t._v(" "),r("ul",[r("li",[t._v("Double Left Rotation")]),t._v(" "),r("li",[t._v("Double Right Rotation")])]),t._v(" "),r("h4",{attrs:{id:"실행기준"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#실행기준"}},[t._v("#")]),t._v(" 실행기준")]),t._v(" "),r("p",[t._v("삽입 연산의 double rotation은 다음 두 가지 경우에 실시된다.")]),t._v(" "),r("img",{attrs:{src:"/images/DataStructure/resources/before_drr.PNG",width:"400px"}}),t._v(" "),r("p",[r("code",[t._v("X")]),t._v(": BF의 절대값이 2 이상이면서 새 노드와 가장 가까운 조상 노드"),r("br"),t._v(" "),r("code",[t._v("Y")]),t._v(": X의 자식노드이면서 BF 절대값이 1이하")]),t._v(" "),r("ul",[r("li",[t._v("Y가 X의 왼쪽 자식노드, Y의 오른쪽 서브트리에 새 노드가 삽입된 경우")]),t._v(" "),r("li",[t._v("Y가 X의 오른쪽 자식노드, Y의 왼쪽 서브트리에 새 노드가 삽입된 경우")])]),t._v(" "),r("p",[t._v("위의 그림 예시는 X, Y, Z의 BF가 각각 2, -1, 1이 된다."),r("br"),t._v("\n따라서 X를 루트노드로 하는 서브트리가 균형을 맞춰야될 대상이 된다.")]),t._v(" "),r("h4",{attrs:{id:"double-right-lotation-예시"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#double-right-lotation-예시"}},[t._v("#")]),t._v(" Double Right Lotation 예시")]),t._v(" "),r("img",{attrs:{src:"/images/DataStructure/resources/avl_drr.PNG",width:"600px"}}),t._v(" "),r("ul",[r("li",[t._v("첫번째 : Z를 중심으로 left rotation 수행 (T1를 잡아 당겨 내리는 과정)")]),t._v(" "),r("li",[t._v("두번째 : Z를 중심으로 right rotation 수행 (T4를 잡아 당겨 내리는 과정)")])]),t._v(" "),r("p",[t._v("위 과정을 수행하고 나면 BF가 각각 -1, 0, 0이 되어서 균형을 이루게 된다.")]),t._v(" "),r("h2",{attrs:{id:"_3-예제-프로그램"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-예제-프로그램"}},[t._v("#")]),t._v(" 3. 예제 프로그램")]),t._v(" "),r("div",{staticClass:"language-Java extra-class"},[r("pre",{pre:!0,attrs:{class:"language-java"}},[r("code",[t._v("\n")])])])])}),[],!1,null,null,null);a.default=_.exports}}]);