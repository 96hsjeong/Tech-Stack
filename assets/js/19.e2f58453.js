(window.webpackJsonp=window.webpackJsonp||[]).push([[19],{270:function(e,n,t){e.exports=t.p+"assets/img/BFS_1.1174b3f3.jpg"},271:function(e,n,t){e.exports=t.p+"assets/img/BFS_2.17e3cc01.jpg"},367:function(e,n,t){"use strict";t.r(n);var a=t(19),s=Object(a.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"너비-우선-탐색-breadth-first-search-bfs"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#너비-우선-탐색-breadth-first-search-bfs"}},[e._v("#")]),e._v(" 너비 우선 탐색(Breadth First Search : BFS)")]),e._v(" "),a("p",[a("em",[e._v("written by sohyeon, hyemin 💡")])]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"_1-너비-우선-탐색-bfs-이란"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-너비-우선-탐색-bfs-이란"}},[e._v("#")]),e._v(" 1. 너비 우선 탐색(BFS)이란?")]),e._v(" "),a("p",[a("code",[e._v("너비 우선 탐색(Breadth First Search)")]),e._v("은 시작 노드로부터 가까운 노드를 먼저 방문하고 멀리 떨어져 있는 노드를 나중에 방문하는 순회 방법이다.")]),e._v(" "),a("p",[e._v("예를 들어, a 노드에서 시작한다고 했을 때, BFS는 a 노드의 이웃 노드를 모두 방문한 다음에 이웃의 이웃들을 방문한다.")]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"_2-너비-우선-탐색-bfs-의-특징"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-너비-우선-탐색-bfs-의-특징"}},[e._v("#")]),e._v(" 2. 너비 우선 탐색(BFS)의 특징")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("BFS는 DFS와 달리 재귀적으로 동작하지 않는다.")])]),e._v(" "),a("li",[a("p",[e._v("BFS는 방문한 노드를 차례로 저장한 후 꺼낼 수 있는 큐(queue)를 사용한다.")])])]),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"_3-너비-우선-탐색-bfs-의-과정"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-너비-우선-탐색-bfs-의-과정"}},[e._v("#")]),e._v(" 3. 너비 우선 탐색(BFS)의 과정")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("1. 먼저 시작 노드인 0을 방문한 다음, 큐에 삽입한다.\n2. 노드 0의 인접 노드인 {1,2,4}를 차례대로 방문한 다음, 큐에 삽입한다.\n3. 큐에 삽입된 {1,2,4} 순으로 큐에서 삭제하면서 인접한 노드에 방문 가능한지 확인한다. \n4. {1}의 인접한 노드 {0,2}는 이미 방문했으므로 큐에서 삭제한다.\n5. {2}의 인접한 노드 {1,0,3,4}에서 방문하지 않는 {3}을 방문한 후 큐에서 삭제한다.\n6. 앞의 순서와 마찬가지로 모든 노드를 방문하고, 탐색을 종료한다.\n")])])]),a("img",{attrs:{src:t(270),height:"400px"}}),e._v(" "),a("img",{attrs:{src:t(271),height:"410px"}}),e._v(" "),a("br"),e._v(" "),a("h2",{attrs:{id:"_4-너비-우선-탐색-bfs-의-구현"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-너비-우선-탐색-bfs-의-구현"}},[e._v("#")]),e._v(" 4. 너비 우선 탐색(BFS)의 구현")]),e._v(" "),a("p",[e._v("구현 방법으로는 자료 구조 "),a("code",[e._v("큐(queue)를 이용하는 것")]),e._v("이다.")]),e._v(" "),a("h4",{attrs:{id:"ex-bfs를-구현한-의사코드-pseudocode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ex-bfs를-구현한-의사코드-pseudocode"}},[e._v("#")]),e._v(" ex) BFS를 구현한 의사코드(pseudocode)")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("void search(Node root) {\n    Queue queue = new Queue();\n    root.marked = true; \n    queue.enqueue(root); // 루트 노드를 큐의 끝에 추가한다.\n\n    // 큐가 비어 있을 때까지 계속한다.\n    while (!queue.isEmpty()) {\n        Node r = queue.dequeue(); // 큐의 앞에서 삭제한다.\n        visit(r); // 큐에서 삭제한 노드를 방문한다. \n        \n        // 큐에서 삭제한 노드와 인접한 노드들을 모두 차례로 방문한다.\n        foreach (Node n in r.adjacent) {\n            if (n.marked == false) {\n                n.marked = true; \n                queue.enqueue(n); // 큐의 끝에 추가한다.\n            }\n        }\n    }\n}\n")])])]),a("h4",{attrs:{id:"bfs-구현"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bfs-구현"}},[e._v("#")]),e._v(" BFS 구현")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('import java.io.*; \nimport java.util.*; \n\n// 인접 리스트를 이용한 방향성 있는 그래프 클래스\nclass Graph { \n    private int V; // 노드의 개수\n    private LinkedList<Integer> adj[]; // 인접 리스트\n\n    // Constructor(생성자)\n    Graph(int v) { \n        V = v; \n        adj = new LinkedList[v]; \n        for (int i=0; i<v; ++i) \n            adj[i] = new LinkedList(); \n    } \n\n    // 노드를 연결한다. (v->w)\n    void addEdge(int v,int w) { \n        adj[v].add(w); \n    } \n\n    // s를 시작 노드로 BFS를 탐색한다.\n    void BFS(int s) { \n        // 노드의 방문 여부를 판단한다.  \n        boolean visited[] = new boolean[V]; \n\n        // BFS 구현을 위한 큐(queue)를 생성한다.\n        LinkedList<Integer> queue = new LinkedList<Integer>(); \n\n        // 현재 노드를 방문한 것으로 표시하고 큐에 삽입(add)한다.\n        visited[s]=true; \n        queue.add(s); \n\n        // 큐가 비어 있을 때까지 반복한다.\n        while (queue.size() != 0) { \n            // 큐에서 방문한 노드를 삭제(poll)하고 값을 출력한다.\n            s = queue.poll(); \n            System.out.print(s+" "); \n\n            // 방문한 노드와 인접한 모든 노드를 가져온다.\n            Iterator<Integer> i = adj[s].listIterator(); \n            while (i.hasNext()) { \n                int n = i.next(); \n                \n                // 방문하지 않은 노드가 있다면 방문한 것으로 표시하고 큐에 삽입(add)한다.\n                if (!visited[n]) { \n                    visited[n] = true; \n                    queue.add(n); \n                } \n            } \n        } \n    } \n\n    // 2를 시작 노드로 하여 BFS를 탐색한다.\n    public static void main(String args[]) { \n        Graph g = new Graph(4); \n\n        g.addEdge(0, 1); \n        g.addEdge(0, 2); \n        g.addEdge(1, 2); \n        g.addEdge(2, 0); \n        g.addEdge(2, 3); \n        g.addEdge(3, 3); \n    \n        g.BFS(2); \n    } \n} \n')])])]),a("br"),e._v(" "),a("h2",{attrs:{id:"reference-additional-resources"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#reference-additional-resources"}},[e._v("#")]),e._v(" Reference & Additional Resources")]),e._v(" "),a("ul",[a("li",[a("p",[e._v("코딩인터뷰 완전 분석")])]),e._v(" "),a("li",[a("p",[e._v("C언어로 쉽게 풀어쓴 자료 구조")])]),e._v(" "),a("li",[a("p",[a("a",{attrs:{href:"https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/",target:"_blank",rel:"noopener noreferrer"}},[e._v("https://www.geeksforgeeks.org/breadth-first-search-or-bfs-for-a-graph/"),a("OutboundLink")],1)])])])])}),[],!1,null,null,null);n.default=s.exports}}]);